
// Generated by JTB 1.3.2
//

package visitor;

import syntaxtree.*;
import java.util.*;
import representation.*;
import java.util.ArrayList;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class ProgramConstructor extends DepthFirstVisitor {

	Program p;

	int size;
	ArrayList<Operation> ops = new ArrayList<Operation>();
	boolean assertionPresent = false;
	ArrayList<Qubit> assertionv1 = new ArrayList<Qubit>();
	ArrayList<Qubit> assertionv2 = new ArrayList<Qubit>();
	int measureLo;
	int measureHi;

	String gate;
	ArrayList<Qubit> currentvector;
	matrix.Complex amplitude;
	matrix.Complex amplitude0;
	matrix.Complex amplitude1;
	String ket;
	double re;
	matrix.Complex co;
	boolean negativesign;

	public Program getProgram() {
		return p;
	}

	//
	// Auto class visitors--probably don't need to be overridden.
	//
	public void visit(NodeList n) {
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();)
			e.nextElement().accept(this);
	}

	public void visit(NodeListOptional n) {
		if (n.present())
			for (Enumeration<Node> e = n.elements(); e.hasMoreElements();)
				e.nextElement().accept(this);
	}

	public void visit(NodeOptional n) {
		if (n.present())
			n.node.accept(this);
	}

	public void visit(NodeSequence n) {
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();)
			e.nextElement().accept(this);
	}

	public void visit(NodeToken n) {
	}

	//
	// User-generated visitor methods below
	//

	/**
	 * f0 -> Init() f1 -> ( Instruction() )* f2 -> [ Assertion() ] f3 -> Measure()
	 * f4 -> <EOF>
	 */
	public void visit(Goal n) {
		n.f0.accept(this);
		n.f1.accept(this);
		n.f2.accept(this);
		n.f3.accept(this);
		// java.util.Collections.reverse(assertionv1);
		// java.util.Collections.reverse(assertionv2);
		this.p = new Program(size, ops, assertionPresent, assertionv1, assertionv2, measureLo, measureHi);
	}

	/**
	 * f0 -> "circuit" f1 -> ":" f2 -> IntegerLiteral() f3 -> "qubits"
	 */
	public void visit(Init n) {
		this.size = Integer.parseInt(n.f2.f0.toString());
	}

	/**
	 * f0 -> OneQubitInstruction() | TwoQubitInstruction() | ThreeQubitInstruction()
	 */
	public void visit(Instruction n) {
		n.f0.accept(this);
	}

	/**
	 * f0 -> OneQubitGate() f1 -> "(" f2 -> IntegerLiteral() f3 -> ")"
	 */
	public void visit(OneQubitInstruction n) {
		n.f0.accept(this);
		int arg = Integer.parseInt(n.f2.f0.toString());
		ops.add(new OneQubitOperation(this.gate, arg));
	}

	/**
	 * f0 -> TwoQubitGate() f1 -> "(" f2 -> IntegerLiteral() f3 -> "," f4 ->
	 * IntegerLiteral() f5 -> ")"
	 */
	public void visit(TwoQubitInstruction n) {
		n.f0.accept(this);
		int arg1 = Integer.parseInt(n.f2.f0.toString());
		int arg2 = Integer.parseInt(n.f4.f0.toString());
		ops.add(new TwoQubitOperation(this.gate, arg1, arg2));
	}

	/**
	 * f0 -> ThreeQubitGate() f1 -> "(" f2 -> IntegerLiteral() f3 -> "," f4 ->
	 * IntegerLiteral() f5 -> "," f6 -> IntegerLiteral() f7 -> ")"
	 */
	public void visit(ThreeQubitInstruction n) {
		n.f0.accept(this);
		int arg1 = Integer.parseInt(n.f2.f0.toString());
		int arg2 = Integer.parseInt(n.f4.f0.toString());
		int arg3 = Integer.parseInt(n.f6.f0.toString());
		ops.add(new ThreeQubitOperation(this.gate, arg1, arg2, arg3));
	}

	/**
	 * f0 -> "H" | "T" | "X" | "Z" | "D" | "S"
	 */
	public void visit(OneQubitGate n) {
		this.gate = ((NodeToken) (n.f0.choice)).toString();
	}

	/**
	 * f0 -> "CNOT" | "CZ"
	 */
	public void visit(TwoQubitGate n) {
		this.gate = ((NodeToken) (n.f0.choice)).toString();
	}

	/**
	 * f0 -> "CCNOT" | "NCCNOT" | "CNCNOT" | "NCNCNOT"
	 */
	public void visit(ThreeQubitGate n) {
		this.gate = ((NodeToken) (n.f0.choice)).toString();
	}

	/**
	 * f0 -> "assert" f1 -> "state" f2 -> "in" f3 -> "span" f4 -> "{" f5 ->
	 * AVector() f6 -> "," f7 -> AVector() f8 -> "}"
	 */
	public void visit(Assertion n) {
		this.assertionPresent = true;

		this.currentvector = assertionv1;
		n.f5.accept(this);

		this.currentvector = assertionv2;
		n.f7.accept(this);
	}

	/**
	 * f0 -> Component() f1 -> ( Component() )*
	 */
	public void visit(AVector n) {
		n.f0.accept(this);
		n.f1.accept(this);
	}

	/**
	 * f0 -> BracketedComponent() | Ket()
	 */
	public void visit(Component n) {
		n.f0.accept(this);
	}

	/**
	 * f0 -> "(" f1 -> [ Amplitude() ] f2 -> Ket() f3 -> "+" f4 -> [ Amplitude() ]
	 * f5 -> Ket() f6 -> ")"
	 */
	public void visit(BracketedComponent n) {
		// We assume that n.f2 is |0> and that n.f5 is |1>.

		this.amplitude0 = new matrix.Complex(1);
		this.amplitude1 = new matrix.Complex(1);

		n.f1.accept(this);
		this.amplitude0 = this.amplitude;

		n.f4.accept(this);
		this.amplitude1 = this.amplitude;

		currentvector.add(new Qubit(this.amplitude0, this.amplitude1));
	}

	/**
	 * f0 -> Real() | Complex()
	 */
	public void visit(Amplitude n) {
		if (n.f0.which == 0) { // n.f0 contains a Real()
			this.amplitude = new matrix.Complex(this.re, 0);
		} else { // n.f0 contains a Complex()
			this.amplitude = this.co;
		}
	}

	/**
	 * f0 -> "|" f1 -> ( KetContent() )+ f2 -> ">"
	 */
	public void visit(Ket n) {
		n.f1.accept(this);
	}

	/**
	 * f0 -> IntegerLiteral() | "+" | "-"
	 */
	public void visit(KetContent n) {
		double onedivsqrt2 = 1 / Math.sqrt(2);
		if (n.f0.which == 0) { // n.f0 contains an IntegerLiteral()
			// We assume that n.f0 contains all 0s and 1s.
			IntegerLiteral intlit = (IntegerLiteral) (n.f0.choice);
			String s = intlit.f0.toString();
			for (int i = 0; i < s.length(); i++) {
				if (s.charAt(i) == '0') {
					currentvector.add(new Qubit(new matrix.Complex(1), new matrix.Complex(0)));
				} else if (s.charAt(i) == '1') {
					currentvector.add(new Qubit(new matrix.Complex(0), new matrix.Complex(1)));
				} else {
					throw new NullPointerException("Illegal integer in ket");
				}
			}
		} else if (n.f0.which == 1) { // n.f0 contains "+"
			currentvector.add(new Qubit(new matrix.Complex(onedivsqrt2, 0), new matrix.Complex(onedivsqrt2, 0)));
		} else { // n.f0 contains "-"
			currentvector.add(new Qubit(new matrix.Complex(onedivsqrt2, 0), new matrix.Complex(-onedivsqrt2, 0)));
		}
	}

	/**
	 * f0 -> "(" f1 -> Real() f2 -> "+" f3 -> Real() f4 -> "i" f5 -> ")"
	 */
	public void visit(Complex n) {
		n.f1.accept(this);
		double temp = this.re;
		n.f3.accept(this);
		this.co = new matrix.Complex(temp, this.re);
	}

	/**
	 * f0 -> [ Sign() ] f1 -> IntegerLiteral() f2 -> "." f3 -> IntegerLiteral()
	 */
	public void visit(Real n) {
		this.negativesign = false;
		n.f0.accept(this);
		int i = Integer.parseInt(n.f1.f0.toString());
		String s = n.f3.f0.toString();
		int d = Integer.parseInt(s);
		this.re = i + (d / Math.pow(10, s.length()));
		if (this.negativesign) {
			this.re = -this.re;
		}
	}

	/**
	 * f0 -> "-"
	 */
	public void visit(Sign n) {
		this.negativesign = true;
	}

	/**
	 * f0 -> "measure" f1 -> IntegerLiteral() f2 -> ".." f3 -> IntegerLiteral()
	 */
	public void visit(Measure n) {
		this.measureLo = Integer.parseInt(n.f1.f0.toString());
		this.measureHi = Integer.parseInt(n.f3.f0.toString());
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public void visit(IntegerLiteral n) {
		n.f0.accept(this);
	}

}
