//
// Generated by JTB 1.3.2
//

options {
   JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(QuantumParser)
import syntaxtree.*;
import java.util.Vector;


public class QuantumParser 
{
}

class JTBToolkit {
   static NodeToken makeNodeToken(Token t) {
      return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
   }
}


PARSER_END(QuantumParser)

SKIP :
{
   " "
   | "\t"
   | "\n"
   | "\r"
   | "\f"
}

SPECIAL_TOKEN :
{
   <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")>
   | <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*", "/"] (~["*"])* "*"))* "/">
   | <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*", "/"] (~["*"])* "*"))* "/">
}

TOKEN :
{
   <LPAREN: "(">
   | <RPAREN: ")">
   | <LSQPAREN: "[">
   | <RSQPAREN: "]">
   | <LBRACE: "{">
   | <RBRACE: "}">
   | <SEMICOLON: ";">
   | <DOT: ".">
   | <ASSIGN: "=">
   | <LT: "<">
   | <PLUS: "+">
   | <MINUS: "-">
   | <AND: "&&">
   | <NOT: "!">
   | <BOOLEAN: "boolean">
   | <CLASS: "class">
   | <INTERFACE: "interface">
   | <ELSE: "else">
   | <EXTENDS: "extends">
   | <FALSE: "false">
   | <IF: "if">
   | <WHILE: "while">
   | <INTEGER: "int">
   | <LENGTH: "length">
   | <MAIN: "main">
   | <NEW: "new">
   | <PUBLIC: "public">
   | <RETURN: "return">
   | <STATIC: "static">
   | <STRING: "String">
   | <THIS: "this">
   | <TRUE: "true">
   | <PRINT: "System.out.println">
   | <VOID: "void">
   | <H: "H">
   | <X: "X">
   | <T: "T">
   | <CNOT: "CNOT">
   | <q: "q">
   | <qreg: "qreg">
   | <measure: "measure">
   | <circuit: "circuit">
   | <qubits: "qubits">
}

TOKEN :
{
   <INTEGER_LITERAL: (["1"-"9"] (["0"-"9"])* | "0")>
}

TOKEN :
{
   <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
   | <#LETTER: ["$", "A"-"Z", "_", "a"-"z", "\u00c0"-"\u00d6", "\u00d8"-"\u00f6", "\u00f8"-"\u00ff", "\u0100"-"\u1fff", "\u3040"-"\u318f", "\u3300"-"\u337f", "\u3400"-"\u3d2d", "\u4e00"-"\u9fff", "\uf900"-"\ufaff"]>
   | <#DIGIT: ["0"-"9", "\u0660"-"\u0669", "\u06f0"-"\u06f9", "\u0966"-"\u096f", "\u09e6"-"\u09ef", "\u0a66"-"\u0a6f", "\u0ae6"-"\u0aef", "\u0b66"-"\u0b6f", "\u0be7"-"\u0bef", "\u0c66"-"\u0c6f", "\u0ce6"-"\u0cef", "\u0d66"-"\u0d6f", "\u0e50"-"\u0e59", "\u0ed0"-"\u0ed9", "\u1040"-"\u1049"]>
}

Goal Goal() :
{
   Init n0;
   NodeListOptional n1 = new NodeListOptional();
   Instruction n2;
   Measure n3;
   NodeToken n4;
   Token n5;

   
}
{
   n0=Init()
   (
      n2=Instruction()
      { n1.addNode(n2); }
   )*
   { n1.nodes.trimToSize(); }
   n3=Measure()
   n5=<EOF> { 
      n5.beginColumn++; n5.endColumn++;
      n4 = JTBToolkit.makeNodeToken(n5);
   }
   
   { return new Goal(n0,n1,n3,n4); }
}

Init Init() :
{
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   IntegerLiteral n4;
   NodeToken n5;
   Token n6;

   
}
{
   n1="circuit" { n0 = JTBToolkit.makeNodeToken(n1); }
   n3=":" { n2 = JTBToolkit.makeNodeToken(n3); }
   n4=IntegerLiteral()
   n6="qubits" { n5 = JTBToolkit.makeNodeToken(n6); }
   
   { return new Init(n0,n2,n4,n5); }
}

Instruction Instruction() :
{
   NodeChoice n0;
   OneQubitInstruction n1;
   TwoQubitInstruction n2;

   
}
{
   (
      n1=OneQubitInstruction()
      { n0 = new NodeChoice(n1, 0); }
   |
      n2=TwoQubitInstruction()
      { n0 = new NodeChoice(n2, 1); }
   )
   
   { return new Instruction(n0); }
}

OneQubitInstruction OneQubitInstruction() :
{
   OneQubitGate n0;
   NodeToken n1;
   Token n2;
   IntegerLiteral n3;
   NodeToken n4;
   Token n5;

   
}
{
   n0=OneQubitGate()
   n2="(" { n1 = JTBToolkit.makeNodeToken(n2); }
   n3=IntegerLiteral()
   n5=")" { n4 = JTBToolkit.makeNodeToken(n5); }
   
   { return new OneQubitInstruction(n0,n1,n3,n4); }
}

TwoQubitInstruction TwoQubitInstruction() :
{
   TwoQubitGate n0;
   NodeToken n1;
   Token n2;
   IntegerLiteral n3;
   NodeToken n4;
   Token n5;
   IntegerLiteral n6;
   NodeToken n7;
   Token n8;

   
}
{
   n0=TwoQubitGate()
   n2="(" { n1 = JTBToolkit.makeNodeToken(n2); }
   n3=IntegerLiteral()
   n5="," { n4 = JTBToolkit.makeNodeToken(n5); }
   n6=IntegerLiteral()
   n8=")" { n7 = JTBToolkit.makeNodeToken(n8); }
   
   { return new TwoQubitInstruction(n0,n1,n3,n4,n6,n7); }
}

OneQubitGate OneQubitGate() :
{
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;

   
}
{
   (
      n2="H" { n1 = JTBToolkit.makeNodeToken(n2); }
      { n0 = new NodeChoice(n1, 0); }
   |
      n4="T" { n3 = JTBToolkit.makeNodeToken(n4); }
      { n0 = new NodeChoice(n3, 1); }
   |
      n6="X" { n5 = JTBToolkit.makeNodeToken(n6); }
      { n0 = new NodeChoice(n5, 2); }
   )
   
   { return new OneQubitGate(n0); }
}

TwoQubitGate TwoQubitGate() :
{
   NodeToken n0;
   Token n1;

   
}
{
   n1="CNOT" { n0 = JTBToolkit.makeNodeToken(n1); }
   
   { return new TwoQubitGate(n0); }
}

Measure Measure() :
{
   NodeToken n0;
   Token n1;
   IntegerLiteral n2;
   NodeToken n3;
   Token n4;
   IntegerLiteral n5;

   
}
{
   n1="measure" { n0 = JTBToolkit.makeNodeToken(n1); }
   n2=IntegerLiteral()
   n4=".." { n3 = JTBToolkit.makeNodeToken(n4); }
   n5=IntegerLiteral()
   
   { return new Measure(n0,n2,n3,n5); }
}

IntegerLiteral IntegerLiteral() :
{
   NodeToken n0;
   Token n1;

   
}
{
   n1=<INTEGER_LITERAL> { n0 = JTBToolkit.makeNodeToken(n1); }
   
   { return new IntegerLiteral(n0); }
}
